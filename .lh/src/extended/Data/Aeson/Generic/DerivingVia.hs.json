{
    "sourceFile": "src/extended/Data/Aeson/Generic/DerivingVia.hs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1686322175296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1686322183844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n import           Data.Reflection (Reifies (..))\n import           GHC.Generics    (Generic, Rep)\n import GHC.TypeLits\n     ( KnownNat, KnownSymbol, natVal, symbolVal, Nat, Symbol )\n-import Data.Typeable\n+import Data.Typeable (Typeable)\n \n newtype WithOptions options a = WithOptions { runWithOptions :: a }\n \n data StrFun = Drop     Nat\n"
                },
                {
                    "date": 1686322216242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,8 +68,9 @@\n import           GHC.Generics    (Generic, Rep)\n import GHC.TypeLits\n     ( KnownNat, KnownSymbol, natVal, symbolVal, Nat, Symbol )\n import Data.Typeable (Typeable, typeRep)\n+import Data.List (stripPrefix)\n \n newtype WithOptions options a = WithOptions { runWithOptions :: a }\n \n data StrFun = Drop     Nat\n"
                }
            ],
            "date": 1686322175296,
            "name": "Commit-0",
            "content": "{-\ndata MyConfig = MyConfig { mcNameOfProcess :: String\n                         , mcArgsToProcess :: [String]\n                         }\n  deriving (Read, Show, Eq, Ord, Generic)\n  deriving (ToJSON, FromJSON)\n       via WithOptions '[ FieldLabelModifier     '[CamelTo2 \"_\" , Drop 2]\n                        , ConstructorTagModifier '[CamelTo2 \"_\"]\n                        ]\n                        MyConfig\n\ndata Init\ninstance Reifies Init (String -> String) where\n  reflect _ = init\n\ndata OtherConfig = OtherConfig { otrNameOfProcess :: Maybe String\n                               , otrArgsToProcess :: [String]\n                               }\n  deriving (Read, Show, Eq, Ord, Generic)\n  deriving (ToJSON, FromJSON)\n       via WithOptions '[ FieldLabelModifier     '[CamelTo2 \"-\"]\n                        , ConstructorTagModifier '[CamelTo2 \"-\", UserDefined Init]\n                        , SumEnc                  TwoElemArr\n                        , TagSingleConstructors  'True\n                        , OmitNothingFields      'True\n                        ]\n                        OtherConfig\n-}\n\n{-# LANGUAGE ConstraintKinds, DataKinds, DeriveGeneric, DerivingVia    #-}\n{-# LANGUAGE ExplicitNamespaces, FlexibleContexts, FlexibleInstances   #-}\n{-# LANGUAGE GADTs, GeneralizedNewtypeDeriving, MultiParamTypeClasses  #-}\n{-# LANGUAGE PolyKinds, ScopedTypeVariables, StandaloneDeriving        #-}\n{-# LANGUAGE TypeApplications, TypeFamilies, TypeInType, TypeOperators #-}\n{-# LANGUAGE UndecidableInstances                                      #-}\n\nmodule Data.Aeson.Generic.DerivingVia\n     ( StrFun(..), Setting(..), SumEncoding'(..), DefaultOptions, WithOptions(..)\n     , -- Utility type synonyms to save ticks (') before promoted data constructors\n       type Drop, type CamelTo2, type UserDefined\n     , type TaggedObj, type UntaggedVal, type ObjWithSingleField, type TwoElemArr\n     , type FieldLabelModifier\n     , type ConstructorTagModifier\n     , type AllNullaryToStringTag\n     , type OmitNothingFields\n     , type SumEnc\n     , type UnwrapUnaryRecords\n     , type TagSingleConstructors\n     , StripConstructor\n     )\n  where\n    \nimport Data.Aeson\n    ( FromJSON(..),\n      GFromJSON,\n      GToJSON,\n      ToJSON(..),\n      Options(..),\n      Zero,\n      camelTo2,\n      genericParseJSON,\n      defaultOptions,\n      genericToJSON )\nimport qualified Data.Aeson      as Aeson\nimport           Data.Kind       (Constraint, Type)\nimport           Data.Proxy      (Proxy (..))\nimport           Data.Reflection (Reifies (..))\nimport           GHC.Generics    (Generic, Rep)\nimport GHC.TypeLits\n    ( KnownNat, KnownSymbol, natVal, symbolVal, Nat, Symbol )\n\nnewtype WithOptions options a = WithOptions { runWithOptions :: a }\n\ndata StrFun = Drop     Nat\n            | CamelTo2 Symbol\n            | forall p. UserDefined p\n\ntype Drop = 'Drop\ntype CamelTo2 = 'CamelTo2\ntype UserDefined = 'UserDefined\n\ntype family Demoted a where\n  Demoted Symbol  = String\n  Demoted StrFun  = String -> String\n  Demoted [a]     = [Demoted a]\n  Demoted Setting = Options -> Options\n  Demoted SumEncoding' = Aeson.SumEncoding\n  Demoted a = a\n\ndata SumEncoding' = TaggedObj {tagFieldName' :: Symbol, contentsFieldName :: Symbol }\n                  | UntaggedVal\n                  | ObjWithSingleField\n                  | TwoElemArr\n\ntype TaggedObj          = 'TaggedObj\ntype UntaggedVal        = 'UntaggedVal\ntype ObjWithSingleField = 'ObjWithSingleField\ntype TwoElemArr         = 'TwoElemArr\n\ndata Setting = FieldLabelModifier     [StrFun]\n             | ConstructorTagModifier [StrFun]\n             | AllNullaryToStringTag  Bool\n             | OmitNothingFields      Bool\n             | SumEnc                 SumEncoding'\n             | UnwrapUnaryRecords     Bool\n             | TagSingleConstructors  Bool\n\ntype FieldLabelModifier     = 'FieldLabelModifier\ntype ConstructorTagModifier = 'ConstructorTagModifier\ntype AllNullaryToStringTag  = 'AllNullaryToStringTag\ntype OmitNothingFields      = 'OmitNothingFields\ntype SumEnc                 = 'SumEnc\ntype UnwrapUnaryRecords     = 'UnwrapUnaryRecords\ntype TagSingleConstructors  = 'TagSingleConstructors\n\nclass Demotable (a :: k) where\n  demote :: proxy a -> Demoted k\n\ntype family All (p :: Type -> Constraint) (xs :: [Type]) :: Constraint where\n  All p '[] = ()\n  All p (x ': xs) = (p x, All p xs)\n\ninstance Reifies f (String -> String) => Demotable ('UserDefined f) where\n  demote _ = reflect @f Proxy\n\ninstance KnownSymbol sym => Demotable sym where\n  demote = symbolVal\n\ninstance (KnownSymbol s, KnownSymbol t) => Demotable ('TaggedObj s t) where\n  demote _ = Aeson.TaggedObject (symbolVal @s Proxy) (symbolVal @t Proxy)\n\ninstance Demotable 'UntaggedVal where\n  demote _ = Aeson.UntaggedValue\n\ninstance Demotable 'ObjWithSingleField where\n  demote _ = Aeson.ObjectWithSingleField\n\ninstance Demotable 'TwoElemArr where\n  demote _ = Aeson.TwoElemArray\n\ninstance Demotable xs => Demotable ('FieldLabelModifier xs) where\n  demote _ o = o { fieldLabelModifier = foldr (.) id (demote (Proxy @xs)) }\n\ninstance Demotable xs => Demotable ('ConstructorTagModifier xs) where\n  demote _ o = o { constructorTagModifier = foldr (.) id (demote (Proxy @xs)) }\n\ninstance Demotable b => Demotable ('AllNullaryToStringTag b) where\n  demote _ o = o { allNullaryToStringTag = demote (Proxy @b) }\n\ninstance Demotable b => Demotable ('OmitNothingFields b) where\n  demote _ o = o { omitNothingFields = demote (Proxy @b) }\n\ninstance Demotable b => Demotable ('UnwrapUnaryRecords b) where\n  demote _ o = o { unwrapUnaryRecords = demote (Proxy @b) }\n\ninstance Demotable b => Demotable ('TagSingleConstructors b) where\n  demote _ o = o { tagSingleConstructors = demote (Proxy @b) }\n\ninstance Demotable b => Demotable ('SumEnc b) where\n  demote _ o = o { sumEncoding = demote (Proxy @b) }\n\ninstance Demotable 'True where\n  demote _ = True\n\ninstance Demotable 'False where\n  demote _ = False\n\ninstance KnownNat n => Demotable ('Drop n) where\n  demote _ = drop (fromIntegral $ natVal (Proxy :: Proxy n))\n\ninstance KnownSymbol sym => Demotable ('CamelTo2 sym) where\n  demote _ = camelTo2 $ head $ symbolVal @sym Proxy\n\ninstance {-# OVERLAPPING #-} Demotable ('[] :: [k]) where\n  demote _ = []\n\ninstance (Demotable (x :: k), Demotable (xs :: [k])) => Demotable (x ': xs) where\n  demote _ = demote (Proxy @x) : demote (Proxy @xs)\n\ntype DefaultOptions = ('[] :: [Setting])\n\nreflectOptions :: forall xs proxy. Demotable (xs :: [Setting]) => proxy xs -> Options\nreflectOptions pxy = foldr ($) defaultOptions (demote pxy)\n\ninstance (Demotable (options :: [Setting])) => Reifies options Options where\n  reflect = reflectOptions\n\ninstance (Generic a, GToJSON Zero (Rep a), Reifies (options :: k) Options)\n       => ToJSON (WithOptions options a) where\n  toJSON = genericToJSON (reflect (Proxy @options)) . runWithOptions\n\ninstance (Generic a, GFromJSON Zero (Rep a), Reifies (options :: k) Options)\n       => FromJSON (WithOptions options a) where\n  parseJSON = fmap WithOptions . genericParseJSON (reflect (Proxy @options))\n\ndata StripConstructor a\n\ninstance Typeable a => Reifies (StripConstructor a) (String -> String) where\n  reflect _ = \\s -> fromMaybe s $ stripPrefix (show (typeRep (Proxy @a))) s"
        }
    ]
}